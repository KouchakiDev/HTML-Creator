<!-- inputShadow.html — inline box-shadow editor compatible with inspector -->
<div class="shadow-editor" style="display:inline-block;width:100%;box-sizing:border-box">
  <style>
    :root{ --muted:#6b7280; --accent:#3b82f6 }
    .shadow-editor *{box-sizing:border-box}
    .shadow-editor{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;margin:6px;color:#0f1724;background:transparent}
    .header{display:flex;align-items:center;justify-content:space-between;gap:10px}
    .trigger-preview{width:52px;height:22px;border-radius:6px;background:#fff;border:1px solid rgba(15,23,42,0.04);box-shadow:0 6px 18px rgba(16,24,40,0.06)}
    .mini{font-size:12px;color:var(--muted)}
    .panel{margin-top:10px;background:#fff;border-radius:10px;padding:10px;border:1px solid #eef2ff;box-shadow:0 12px 40px rgba(12,20,40,0.04)}
    .body{display:flex;gap:12px}
    .controls{flex:1}
    .shadow-list{display:flex;flex-direction:column;gap:8px;max-height:220px;overflow:auto;padding-right:6px}
    .shadow-card{display:flex;flex-direction:column;gap:8px;padding:8px;border-radius:8px;border:1px solid #f0f4ff;background:#fff}
    .shadow-card .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .shadow-card .label{font-size:12px;color:var(--muted);min-width:40px}
    .controls .row{display:flex;gap:8px;align-items:center}
    .shadow-editor input[type=number], .shadow-editor input[type=text]{padding:6px;border-radius:6px;border:1px solid #eef2ff;font-size:13px}
    .shadow-editor input[type=color]{width:36px;height:30px;border-radius:6px;border:0;padding:0}
    .h-range{width:140px;height:18px;appearance:none;background:transparent}
    .h-range::-webkit-slider-runnable-track{height:6px;background:#e6e9f2;border-radius:4px}
    .h-range::-webkit-slider-thumb{appearance:none;width:18px;height:18px;border-radius:50%;background:var(--accent);margin-top:-6px;box-shadow:0 2px 6px rgba(59,130,246,0.22);cursor:pointer}
    .css-out{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:13px;padding:8px;border-radius:6px;background:#0b1220;color:#dff0ff;white-space:pre-wrap;word-break:break-word;overflow:auto;max-height:96px}
    .footer{display:flex;justify-content:flex-end;gap:8px;margin-top:10px}
    .btn{padding:8px 10px;border-radius:8px;border:1px solid #eef2ff;background:#fff;cursor:pointer}
    .btn.primary{background:linear-gradient(180deg,var(--accent),#2563eb);color:#fff;border:none}
    .btn.danger{background:#fff5f5;border-color:#ffdede;color:#ef4444}
    @media (max-width:520px){ .body{flex-direction:column} .shadow-list{max-height:160px} }
  </style>

  <!-- header: preview + quick actions -->
  <div class="header">
    <div style="display:flex;gap:10px;align-items:center">
      <div class="trigger-preview" aria-hidden="true"></div>
      <div class="mini">box-shadow editor</div>
    </div>

    <div style="display:flex;gap:8px">
      <button class="btn add-btn" type="button">Add shadow</button>
      <button class="btn danger clear-btn" type="button">Clear all</button>
    </div>
  </div>

  <!-- inline panel -->
  <div class="panel" role="group" aria-label="Box shadow editor panel">
    <div class="body">
      <div class="controls" style="min-width:320px">
        <div class="shadow-list" aria-live="polite"></div>

        <div style="display:flex;gap:10px;margin-top:10px;align-items:flex-start">
          <div style="flex:1">
            <div class="css-out" aria-atomic="true">box-shadow: none;</div>
          </div>
        </div>
      </div>
    </div>

    <div class="footer">
      <button class="btn" type="button" data-action="copy">Copy CSS</button>
      <button class="btn primary apply-btn" type="button">Apply (notify inspector)</button>
    </div>
  </div>

  <script>
  (function(){
    const container = document.currentScript && document.currentScript.parentElement;
    if(!container) return;

    // scoped nodes
    const previewEl = container.querySelector('.trigger-preview');
    const shadowList = container.querySelector('.shadow-list');
    const cssOut = container.querySelector('.css-out');
    const addBtn = container.querySelector('.add-btn');
    const clearBtn = container.querySelector('.clear-btn');
    const applyBtn = container.querySelector('.apply-btn');
    const copyBtn = container.querySelector('[data-action="copy"]');

    // helpers
    function hexToRgb(hex){ if(!hex) return null; hex = hex.replace('#',''); if(hex.length===3) hex = hex.split('').map(c=>c+c).join(''); if(hex.length!==6) return null; return [parseInt(hex.slice(0,2),16),parseInt(hex.slice(2,4),16),parseInt(hex.slice(4,6),16)]; }
    function rgbaStr(hex,a){ const p = hexToRgb(hex); if(!p) return `rgba(0,0,0,${a})`; return `rgba(${p[0]}, ${p[1]}, ${p[2]}, ${Number(a).toFixed(2)})`; }
    function clamp(v,a,b){ return Math.min(b, Math.max(a, v)); }

    // split top-level commas (avoid splitting inside parentheses)
    function splitTopLevelCommas(s){
      const parts = [];
      let depth = 0;
      let cur = '';
      for(let i=0;i<s.length;i++){
        const ch = s[i];
        if(ch === '(') depth++;
        else if(ch === ')') depth = Math.max(0, depth-1);
        if(ch === ',' && depth === 0){
          parts.push(cur.trim());
          cur = '';
        } else {
          cur += ch;
        }
      }
      if(cur.trim()) parts.push(cur.trim());
      return parts;
    }

    // parse a single shadow string -> object
    function parseShadowPart(part){
      const s = { offsetX:0, offsetY:0, blur:0, spread:0, color:'#000000', alpha:1, inset:false };
      if(!part) return s;
      let text = part.trim();

      // inset
      if(/\binset\b/i.test(text)){ s.inset = true; text = text.replace(/\binset\b/i,'').trim(); }

      // try to extract color (rgba(...), rgb(...), #hex, or word)
      let colorMatch = text.match(/rgba?\([^\)]+\)/i) || text.match(/#[0-9A-Fa-f]{3,6}\b/) || text.match(/[a-zA-Z]+\b/);
      let colorToken = null;
      if(colorMatch){
        colorToken = colorMatch[0];
        text = text.replace(colorToken, '').trim();
        // normalize
        const m = colorToken.match(/rgba?\([^\)]+\)/i);
        if(m){
          // parse rgba
          const nums = m[0].match(/([0-9.]+)/g);
          if(nums && nums.length>=3){
            s.color = rgbToHexSafe(parseFloat(nums[0]), parseFloat(nums[1]), parseFloat(nums[2]));
            s.alpha = nums.length>=4 ? parseFloat(nums[3]) : 1;
          }
        } else if(/^#/.test(colorToken)){
          s.color = colorToken.toUpperCase();
          s.alpha = 1;
        } else {
          // named color -> compute via temporary element
          const tmp = document.createElement('div');
          tmp.style.color = colorToken;
          tmp.style.display = 'none';
          document.body.appendChild(tmp);
          const cs = getComputedStyle(tmp).color;
          document.body.removeChild(tmp);
          const m2 = cs && cs.match(/rgba?\(([^)]+)\)/);
          if(m2){
            const nums = m2[1].split(',').map(x=>x.trim());
            if(nums.length>=3){
              s.color = rgbToHexSafe(parseFloat(nums[0]), parseFloat(nums[1]), parseFloat(nums[2]));
              s.alpha = nums.length>=4 ? parseFloat(nums[3]) : 1;
            }
          }
        }
      }

      // now parse numbers (px) from remaining text
      const nums = text.match(/-?\d+(\.\d+)?px/g) || text.match(/-?\d+(\.\d+)?/g);
      if(nums && nums.length){
        const vals = nums.map(n => parseFloat(String(n).replace('px','')));
        if(vals.length >= 1) s.offsetX = vals[0];
        if(vals.length >= 2) s.offsetY = vals[1];
        if(vals.length >= 3) s.blur = vals[2];
        if(vals.length >= 4) s.spread = vals[3];
      } else {
        // fallback: split by spaces and try numbers
        const toks = text.split(/\s+/).filter(Boolean);
        const parsed = toks.map(t => { const m = t.match(/-?\d+(\.\d+)?/); return m?parseFloat(m[0]):null; }).filter(v=>v!==null);
        if(parsed.length>=1) s.offsetX = parsed[0];
        if(parsed.length>=2) s.offsetY = parsed[1];
        if(parsed.length>=3) s.blur = parsed[2];
        if(parsed.length>=4) s.spread = parsed[3];
      }

      return s;
    }

    function rgbToHexSafe(r,g,b){
      r = Math.round(r||0); g = Math.round(g||0); b = Math.round(b||0);
      return '#' + [r,g,b].map(v => { const s = v.toString(16); return s.length===1 ? '0'+s : s; }).join('').toUpperCase();
    }

    // build css string from shadows array
    function buildCssString(shadows){
      if(!Array.isArray(shadows) || shadows.length===0) return 'none';
      const parts = shadows.map(s => {
        const color = rgbaStr(s.color || '#000000', typeof s.alpha !== 'undefined' ? s.alpha : 1);
        const inset = s.inset ? ' inset' : '';
        return `${s.offsetX}px ${s.offsetY}px ${s.blur || 0}px ${s.spread || 0}px ${color}${inset}`;
      });
      return parts.join(', ');
    }

    // state
    let shadows = [ { offsetX:8, offsetY:8, blur:16, spread:0, color:'#000000', alpha:0.35, inset:false } ];
    let selectedIndex = 0;

    // inspector proxy finder
    function findProxy(){
      let p = container;
      while(p && !p.classList.contains('prop-control')) p = p.parentElement;
      return (p && p.querySelector('.template-proxy')) || document.querySelector('.template-proxy');
    }
    function setInspectorProxyValue(val){
      const proxy = findProxy();
      const str = (typeof val === 'string') ? val : `box-shadow: ${val};`;
      if(proxy){
        proxy.value = str;
        proxy.dispatchEvent(new Event('change', { bubbles:true }));
      }
    }

    // render UI
    function renderList(){
      shadowList.innerHTML = '';
      if(!shadows.length){
        const empty = document.createElement('div');
        empty.className = 'mini';
        empty.textContent = 'No shadows — add one';
        shadowList.appendChild(empty);
        updatePreviewAndOutput();
        return;
      }

      shadows.forEach((s, idx)=>{
        const card = document.createElement('div');
        card.className = 'shadow-card';
        // header row
        const headerRow = document.createElement('div');
        headerRow.className = 'row';
        const title = document.createElement('div'); title.className = 'label mini'; title.textContent = `Shadow ${idx+1}`;
        const selectBtn = document.createElement('button'); selectBtn.className = 'btn'; selectBtn.textContent = (idx === selectedIndex ? 'Selected' : 'Select');
        selectBtn.addEventListener('click', ()=>{ selectedIndex = idx; renderList(); });
        const delBtn = document.createElement('button'); delBtn.className = 'btn danger'; delBtn.textContent = 'Delete'; delBtn.addEventListener('click', ()=>{ shadows.splice(idx,1); selectedIndex = Math.max(0, Math.min(selectedIndex, shadows.length-1)); renderList(); updatePreviewAndOutput(); });
        headerRow.appendChild(title); headerRow.appendChild(selectBtn); headerRow.appendChild(delBtn);
        card.appendChild(headerRow);

        // controls: X, Y, blur, spread
        const row1 = document.createElement('div'); row1.className = 'row';
        row1.appendChild(makeNumberControl('X', s.offsetX, -120, 120, 1, val=>{ s.offsetX = val; updatePreviewAndOutput(); renderList(); }));
        row1.appendChild(makeNumberControl('Y', s.offsetY, -120, 120, 1, val=>{ s.offsetY = val; updatePreviewAndOutput(); renderList(); }));
        row1.appendChild(makeNumberControl('Blur', s.blur, 0, 300, 1, val=>{ s.blur = val; updatePreviewAndOutput(); renderList(); }));
        row1.appendChild(makeNumberControl('Spread', s.spread, -200, 200, 1, val=>{ s.spread = val; updatePreviewAndOutput(); renderList(); }));
        card.appendChild(row1);

        // color + alpha + inset
        const row2 = document.createElement('div'); row2.className = 'row';
        const colorInput = document.createElement('input'); colorInput.type = 'color'; colorInput.value = s.color || '#000000';
        colorInput.addEventListener('input', ()=>{ s.color = colorInput.value.toUpperCase(); updatePreviewAndOutput(); renderList(); });
        const hexInput = document.createElement('input'); hexInput.type = 'text'; hexInput.value = s.color || '#000000'; hexInput.style.width = '84px';
        hexInput.addEventListener('change', ()=>{ const v = hexInput.value.trim(); const m = v.match(/^#?[0-9A-Fa-f]{3,6}$/); if(m){ s.color = v.startsWith('#')? v.toUpperCase() : ('#'+v).toUpperCase(); colorInput.value = s.color; updatePreviewAndOutput(); renderList(); } });
        const alphaCtrl = makeNumberControl('Op', s.alpha, 0, 1, 0.01, val=>{ s.alpha = val; updatePreviewAndOutput(); renderList(); });
        alphaCtrl.num.style.width = '64px';
        const insetLabel = document.createElement('label'); insetLabel.className = 'mini'; insetLabel.textContent = 'Inset';
        const insetCheckbox = document.createElement('input'); insetCheckbox.type = 'checkbox'; insetCheckbox.checked = !!s.inset;
        insetCheckbox.addEventListener('change', ()=>{ s.inset = insetCheckbox.checked; updatePreviewAndOutput(); renderList(); });
        row2.appendChild(colorInput); row2.appendChild(hexInput); row2.appendChild(alphaCtrl.container); row2.appendChild(insetLabel); row2.appendChild(insetCheckbox);
        card.appendChild(row2);

        // highlight selected
        if(idx === selectedIndex){
          card.style.boxShadow = '0 10px 30px rgba(59,130,246,0.06)';
        }

        shadowList.appendChild(card);
      });
    }

    // small helper to create number + range control
    function makeNumberControl(labelText, initial, min, max, step, onChange){
      const wrapper = document.createElement('div');
      wrapper.style.display = 'flex';
      wrapper.style.gap = '6px';
      wrapper.style.alignItems = 'center';

      const lbl = document.createElement('div'); lbl.className = 'label mini'; lbl.textContent = labelText;
      const range = document.createElement('input'); range.type = 'range'; range.className = 'h-range'; range.min = min; range.max = max; range.step = step; range.value = initial;
      const num = document.createElement('input'); num.type = 'number'; num.value = initial; num.min = min; num.max = max; num.step = step; num.style.width = '72px';

      range.addEventListener('input', ()=>{ const v = parseFloat(range.value); num.value = v; if(onChange) onChange(v); });
      num.addEventListener('input', ()=>{ let v = parseFloat(num.value); if(isNaN(v)) v = parseFloat(range.value); v = clamp(v, min, max); range.value = v; num.value = v; if(onChange) onChange(v); });

      wrapper.appendChild(lbl); wrapper.appendChild(range); wrapper.appendChild(num);
      return { container: wrapper, range, num };
    }

    function updatePreviewAndOutput(){
      const cssVal = buildCssString(shadows);
      previewEl.style.boxShadow = cssVal || 'none';
      cssOut.textContent = `box-shadow: ${cssVal || 'none'};`;
      // notify inspector live
      setInspectorProxyValue(cssOut.textContent);
    }

    // find proxy and seed initial from proxy.value or data-value
    function seedInitial(){
      let seeded = false;
      try{
        const proxy = findProxy();
        const pv = proxy && String(proxy.value || '').trim();
        if(pv){
          seeded = parseBoxShadowStringToState(pv);
        }
      }catch(e){}
      if(!seeded){
        const dv = container.dataset && container.dataset.value ? String(container.dataset.value).trim() : '';
        if(dv) seeded = parseBoxShadowStringToState(dv);
      }
      // finally render
      renderList();
      updatePreviewAndOutput();
    }

    // parse a box-shadow declaration (may contain multiple) into shadows array
    function parseBoxShadowStringToState(s){
      if(!s) return false;
      // strip prefix like "box-shadow:" and trailing semicolon
      let val = s.replace(/^box-shadow\s*:\s*/i,'').replace(/;$/,'').trim();
      if(!val) return false;
      const parts = splitTopLevelCommas(val);
      const parsed = parts.map(p => parseShadowPart(p));
      if(parsed.length){
        shadows = parsed;
        selectedIndex = 0;
        return true;
      }
      return false;
    }

    // actions
    addBtn && addBtn.addEventListener('click', ()=>{ shadows.push({ offsetX:10, offsetY:10, blur:20, spread:0, color:'#000000', alpha:0.25, inset:false }); selectedIndex = shadows.length - 1; renderList(); updatePreviewAndOutput(); });
    clearBtn && clearBtn.addEventListener('click', ()=>{ shadows = []; selectedIndex = 0; renderList(); updatePreviewAndOutput(); });
    applyBtn && applyBtn.addEventListener('click', ()=>{ // explicit apply: notify inspector and flash output
      const css = cssOut.textContent;
      setInspectorProxyValue(css);
      cssOut.style.transition = 'none'; cssOut.style.background = '#113344';
      setTimeout(()=> cssOut.style.background = '', 160);
    });
    copyBtn && copyBtn.addEventListener('click', ()=>{ try{ navigator.clipboard.writeText(cssOut.textContent); copyBtn.textContent='Copied'; setTimeout(()=>copyBtn.textContent='Copy CSS',900); }catch(e){ } });

    // expose API
    container.getBoxShadowCSS = ()=> cssOut ? cssOut.textContent : `box-shadow: ${buildCssString(shadows) || 'none'};`;
    container.getPickerState = ()=> ({ shadows: JSON.parse(JSON.stringify(shadows)), selectedIndex });
    container.setPickerState = (st)=>{ if(st && Array.isArray(st.shadows)){ shadows = st.shadows.map(s=>({ offsetX:+s.offsetX||0, offsetY:+s.offsetY||0, blur:+s.blur||0, spread:+s.spread||0, color:s.color||'#000000', alpha:+s.alpha||1, inset:!!s.inset })); selectedIndex = st.selectedIndex||0; renderList(); updatePreviewAndOutput(); } };

    // initial bootstrap
    seedInitial();
  })();
  </script>
</div>
